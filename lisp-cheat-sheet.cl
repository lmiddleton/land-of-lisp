;; Lisp Cheat Sheet

;; Handy Functions

;; defparameter					defines a global variable
;; defvar						defines a global variable, won't overwrite previous values
;; defun						defines a function
;; defclass						defines a new CLOS class
;; defmethod					like defun but allows definition of multiple versions of a function with the same name that each support different datatypes
;; defmacro						defines a macro
;; macroexpand					shows the code generated by a macro; useful for testing/debugging
;; gensym						creates a unique variable name that is guaranteed never to clash with any other variable name in your code (used in macro definitions to prevent previously defined variables being captured/overwritten by the macro)
;; let							defines a local variable; won't allow references to other defined variables
;; let*							like let but allows references to previously defined variables
;; flet							defines a local function
;; lambda						a macro that lets you create a function without giving it a name; unlike regular functions, not all its parameters are necessarily evaluated before the function itself; allows code to take a conceptual leap that bridges the worlds of functions and values; in a mathematical sense, lambda is the only Lisp command there is and tghe central concept from which other functions in Lisp derive
;; labels						makes function names available in defined functions (lets you call one local function from another, and have a function call itself)
;; eval							executes the code stored in a variable; allows writing a self-modifying program; rarely used by experiences Lispers who define macros instead; poses security risks and should be avoided in 	production code
;; quote						quotes a parameter to put it into data mode (the single quote ' is the shorthand); 'foo = (quote foo)
;; setf							performs setting operations in conjunction with getting operations (such as aref) based on where the item in the first argument came from
;; incf							variant of setf that increments a variable
;; decf							variant of setf that subtracts an amount from a variable
;; values						create/return multiple values in a function; the first value is considered more important and is used in follow-up calculations
;; multiple-value-bind			create/return multiple values in a function where the additional returned values can be used in follow-up calculations
;; symbol-function				retrieves the function bound to a symbol

;; Error Handling

;; error						signals a condition directly
;; define-condition				defines a custom condition
;; handler-case					intercepts and handles a conditions defined with defined-condition so it won't stop the program's execution
;; unwind-protect				indicates that a piece of code must run no matter what happens (ex. socket streams); can use "with-" macros to avoid having to call this directly

;; Lists

;; cons							links any two pieces of data
;; car							grabs the value out of the first slot of a cons cell/list
;; cdr							grabs the value out of the second slot of a cons cell/list
;; cadr							uses car and cdr together to grab the second item from a list
;; c*r							any car/cdr function combination up to four levels deep is available out of the box
;; list							automatically creates the cons cells to build a list out of the supplied data
;; push							adds a new item to the front of a list
;; pushnew						adds a new item to the front of a list only if the item is not already present in the list
;; assoc						finds an item in an association list using a key; always returns the first item it finds even if there are duplicates
;; nth							accesses the item at a specific location in a list; slow performance on larger lists
;; find							searches a list for an item and returns that found item
;; member						checks for list membership for an item; returns the tail of the list at the point of the found item
;; set-difference				takes two lists and returns all items that are in the first but not the second
;; remove-duplicates			removes duplicate items from a list (uses eql by default, can be changed with :test keyword parameter)
;; intersection					finds items shared between two lists
;; mapcar						applies a function to every member of a list
;; mapc							like mapcar but doesn't return the transformed list (more efficient)
;; maplist						like mapcar but function inside it receives the entire remainder of the list rather than the current item
;; mapcan						variant of mapcar that assumes the generated values should all be appended together
;; map							like mapcar but works on arrays and strings in addition to lists
;; append						joins several lists into one big list
;; apply						applies a function to every object in a list as if they were separate objects
;; copy-list					creates an explicit copy of a list

;; Arrays

;; make-array					creates a new array of the specified size
;; aref							get and set items in an array (used in conjunction with setf)

;; Hash Tables

;; make-hash-table				creates a new hash table
;; gethash						retrieves an item from a hash table using the item's key; combine with setf to fill the table with data
;; remhash						removes an item from a hash table

;; Structures

;; defstruct					creates a new structure
;; make-*						special function defstruct automatically creates to make a new instance of the structure
;; <name>-<property>			special functions defstruct automatically creates to access a property value in a specified instance of the <name> structure; combine with setf to change properties
;; copy-structure				performs a shallow copy of a structure

;; Equality

;; eq							see if two symbols are identical
;; eql							like eq, but can also check numbers or characters
;; equal						see if two things "look the same"; unless dealing with symbols, use this
;; =							like equal, but handles numbers
;; string-equal					like equal, but handles strings
;; char-equal					like equal, but handles characters
;; equalp						like equal, but handles strings with different CAPS and integers vs. floating point numbers

;; Conditionals

;; if							a special form that makes different things happen when a statment is true vs. false; only one command is ever executed; can also check whether a list is empty
;; progn						wedge extra commands into a single expression (often used with if)
;; when							evaluates all enclosed expressions when the condition is true
;; unless						evaluates all enclosed expressions when the condition is false
;; cond							classic way to do branching in Lisp; the last branch has a condition of t (true), guaranteeing it at least will be evaluated
;; case							lets you supply a value to do comparisons (using eq) against; only used for branching on symbol values, not strings
;; and							mathematical operator to maniputate Boolean values; all values must be true for the expression to evaluate to true
;; or							mathematical operator to manipulate Boolean values; at least one value must be true for the expression to evaluate to true

;; Loops

;; loop							a macro that loops over various types of data; special tokens can be used to affect the loop's behavior:
	;; repeat					specifies how many times to repeat the loop
	;; collect					specifies an object to collect on each loop and return in the form of a list
	;; for						allows you to declare a variable that iterates through a range of values
	;; below					tells the for construct to halt when it reaches a specified value
	;; sum						adds together all values of a given expression
	;; from/to					makes the for construct count through any specific range of integers
	;; in						iterates through values in a list
	;; do						executes an arbitrary expression inside the loop
	;; when						runs the following part of the loop only as needed
;; dotimes						runs a chunk of code a specified number of times
;; return						causes a loop to stop early

;; Input/Output

;; print						prints something to the console, first starting a new line; maintains quotes around strings, etc. so that objects it prints can be read back into their internal representation
;; prin1						like print, but doesn't start a new line
;; prin1-to-string				like prin1, but returns the result as a string rather than dumping it to the screen
;; princ						prints any piece of Lisp data in a "human-preferred" way (for ex. leaves quotes off strings, prints characters in raw form, etc.)
;; terpri						prints a new line
;; fresh-line					prints a new line only if the cursor position isn't already at the front of a line - preferred
;; format						prints text in a variety of ways based on the control sequences used with it:
	;; ~s						formats with appropriate delimiters (such as quotes around a string)
	;; ~a						formats without delimiters to be human-readable (no quotes around strings)
	;; ~x						formats numbers in hexadecimal (base-16)
	;; ~b						formats numbers in binary (base-2)
	;; ~d						formats numbers in decimal (base-10)
	;; ~f						formats numbes as floating-point values
	;; ~$						formats currencies
	;; ~%						causes a new line to be created in all cases (like terpri)
	;; ~&						causes a new line to be created only as needed (like fresh-line)
	;; ~t						formats values in a table/column structure
	;; ~< / ~>					justifies values (ex. spaces values equally apart on a single line)
	;; ~{ / ~}					loops through data
	;; ~:;						breaks text into pieces of equal length
;; with-open-file				create a file stream to write information to a file (best way)
;; read							lets a user enter something in the console; poses security risks and should be avoided in production code
;; read-line
;; read-from-string				like read, but can take in a syntax expression or other basic datatype from a string instead of directly from the console
;; *standard-output*			special global variable that controls the default location to which printing functions send output (output stream associated with the REPL)
;; *standard-input*				input stream associated with the REPL
;; output-stream-p				checks for a valid output stream
;; input-stream-p				checks for a valid input stream
;; write-char					pushes a Lisp character onto an output stream
;; read-char					pops an item off an input stream
;; make-string-output-stream	creates a string output stream
;; make-string-input-stream		creates a string input stream
;; with-open-stream				performs operations on a stream and then closes it
;; with-output-to-string		macro that intercepts any text that would otherwise be output to the console/REPL/other output stream and captures it as a string; handy for debugging; can also be used as a substitute for concatenate
;; read-sequence				fills elements in a sequence with elements read in from a stream

;; Sequence (list, array, string) Functions

;; length						checks the length of a sequence
;; find-if						finds the first value in a sequence that satisfies a predicate
;; count						finds out how often a certain object appears in a sequence
;; position						tells you where an item is located in a sequence
;; some							tells you if some value in a sequence obeys a specific predicate
;; every						tells you if every value in a sequence obeys a specific predicate
;; reduce						iterates through a sequence and distills it down into a single result (higher-order function that accepts a function and a list and will call the function once for every value in the list)
;; subseq						pulls a subsequence out of a larger sequence based on specified starting and ending points
;; sort							sorts a sequence based on the specified function
;; remove-if					removes the elements in a sequence that don't satisfy a predicate

;; Typing

;; type-of						finds the type of any Lisp value
;; numberp						tests if a value is a number
;; arrayp						tests if a value is an array
;; characterp					tests if a value is a character
;; consp						tests if a value is a cons cell
;; functionp					tests if a value is a function
;; hash-table-p					tests if a value is a hash table
;; listp						tests if a value is a list
;; stringp						tests if a value is a string
;; symbolp						tests if a value is a symbol
;; parse-integer				converts a string to an integer
;; intern						converts a string to a Lisp symbol

;; Strings/Characters

;; alphanumericp				tests if a character is alpha-numeric
;; reverse						reverses a string of characters
;; concatenate					combines multiple strings into one
;; coerce						turn a string into a list of characters
;; make-string					creates a string with a specified length
;; code-char					converts an ASCII code into the appropriate character

;; Math/Numbers

;; most-positive-fixnum			returns largest possible postive number
;; most-negative-fixnum			returns largest possible negative number
;; pi							constant that evaluates to 3.14...
;; random						returns a random natural number less than the integer passed to it
;; zerop						tells if a number is 0 or not
;; round						rounds off a number
;; mod							returns the remainder
;; max							returns the real number that is greatest in a list
;; -							subtracts one value from another
;; +							adds one value to another
;; 1+							adds 1 to a value
;; 1-							subtracts 1 from a value
;; *							multiplies two values together
;; /							divides one values by another
;; <							sees if one value is less-than another
;; >=							sees if one value is greater-than or equal to another
;; <=							sees if one value is less-than or equal to another
;; sqrt							takes the square root of a number
;; ash							arithmetic shift function
;; sin							calculates the mathematical sine

;; Timing

;; time							outputs timing stats for a chunk of code

;; Other

;; substitute-if				substitutes values based on the result of a test function; can be used on lists
;; complement					creates the opposite of a predicate function


;; Other Definitions

;; Common Lisp Hyperspec					exhaustive description of Common Lisp functions and features at http://www.snipurl.com/rz3h0

;; expressive								an expressive language is one with which you can do a lot of stuff with very little actual code (ex. Lisp)

;; object-oriented programming (OOP)		commonly used technique for keeping bugs under control by decoupling code; can be done quite nicely in Common Lisp
;; Common Lisp Object System (CLOS)			sophisticated object-oriented programming framework available in Common Lisp
;; Metaobject Protocol (MOP)				allows customization of the Common Lisp Object System (CLOS) at the fundamental level
;; decouple									the act of breaking code into logical components which can be tested independently
;; CLOS class								
;; slot										a property in a CLOS class
;; method									a function designed to operate on a specific type (class) of object in CLOS programming
;; before method							a piece of code that will automatically be called before the main code in a CLOS method
;; multiple dispatch						a powerful technique for writing methods that are chosen based on the types of their parameters

;; functional programming/style				programming style where functions obey the following properties of mathematical functions, resulting in code that can easily be tested in isolation but can be inefficient; the recommended style for writing Lisp
		;; the function always returns the same result as long as the same arguments are passed into it (referential transparency)
		;; the function never references variables defined outside of it (unless the variables are certain to remain constant)
		;; no variables are modified (mutated) by the function
		;; the purpose of the function is to do nothing other than return a result
		;; the function doesn't do anything that is visible to the outside world (ex. pop up a dialog box on the screen)
		;; the function doesn't take information from an outside source (like the keyboard or hard drive)					
;; functional code							code written in the functional style
;; domain									the arguments that may go into a function
;; range									the set of values that may be returned from a function
;; side effect								something visible to the outside world that is caused by a function (ex. display a dialog box on the screen)
;; imperative code							"dirty" code that contains side effects; typically written in a "cookbook" style; the opposite of functional code
;; code composition							combining different chucks of code to perform a single action
;; higher-order (functional) programming	style of programming that relies heavily on passing functions as values, which facilitates easier code composition and functional style programming; the lambda macro enables this style of programming in Lisp
;; hidden state								when a variable set to an original value is allowed to be modified "willy-nilly" in a program; commonly creates bugs in programming language that encourage imperative-style programming if the variables are then referenced later on
;; referential transparency					property of a function that depends on only its arguments for its behavior; this makes bugs easy to duplicate
;; function pipeline						a powerful functional programming technique where a succession of functions operate one after another on a big chunk of data; allows for decoupling the logic piece of a program from the rest
;; lexical (local) variable					a Lisp variable only available in the function it is defined in (unless it is captured in a closure by using a lambda expression)
;; closure									an extra bit of data from the outside world that is captured whenever a lambda function is created in Lisp; often used for caching small pieces of information between uses of a function (ex. function that remembers what line is being printed)
;; memoization								optimization for a function where the function stores the arguments and result of each call of the function so a call with the same arguments can return the precalculated result rather than recalculating the result; makes use of closures and only works for functions written in the functional style
;; tail call								the action of a function in Lisp calling itself (or another function) as its very last action
;; tail call optimization					optimization that a function using tail calls has, where the compiler can go straight to the tail call again without thrashing the stack (safely!); not all Common Lisp compilers will perform tail call optmizations, but most support it

;; macro										a user-created special form with special powers (ex. lambda)
;; macro programming							using macros to turn Lisp into a custom programming language
;; visual noise									extraneous parentheses required by some functions in Lisp
;; special form									a core part of the Lisp language that has special powers beyond those of a standard Lisp function
;; macro expansion								a special transformation of custom macro code just before the core of the Lisp interpreter/compiler sees it
;; runtime										when a function runs at the time of executing the program that contains the function (ex. regular Lisp functions)
;; macro expansion time							when macros are run when the program is read and compiled by the Lisp environment (before the program itself runs)
;; &body										special keyword used in a macro that tells the expander to return all the remaining expressions in the macro in a list
;; anaphoric macros								macros that automatically generate named variables or functions that can be used in the body of the macro
;; domain										an area of human inquiry
;; domain-specific language (DSL)				a custom programming language designed for a specific domain; tend to make heavy use of the Lisp macro system
;; domain-specific language (DSL) programming	advanced macro programming technique that allows solving difficult programming problems by drastically changing the structure and appearance of Lisp code to optimize it for a special purpose

;; random walk								a graph of the result of flipping a coin to move either up or down a step at each moment in time; similar to behavior of stocks and often used as a starting point for financial modeling

;; game tree								a tree of all possible moves for a game, down to the final winning positions
;; lazy evaluation							waiting to evaluate something (ex. the branches of a game tree) until the program needs to look at it
;; lazy game tree							a game tree implemented with lazy evaluation
;; lazy list								a list implemented with lazy evaluation; unlike a regular list, it can be infinite
;; minimax algorithm						algorithm for estimating what a game opponent will do based on the rating of game moves (works only in two-player games)
;; alpha-beta pruning						an optimization of the minimax algorithm that improves performance by skipping over some branches of a game tree if it is certain that they will not impact the final minimax evaluation
;; depth-first search						a feature of the minimax algorithm where it explores all the way down to the leaves while travelling left to right in the game tree
;; chance nodes								

;; continuations							a powerful programming feature in Scheme that allows for "time travel" in code (ex. run a program backwards, sideways)
;; continuation-passing style				feature in Common Lisp that provides limited support for continuations
;; nondeterministic programming				style of programming where the code offers the computer multiple choices for what to do next; if one choice isn't satisfactory, the computer can "roll back time" with continuations to try a different path

;; software transactional memory			allows sharing of complex data structures between several threads

;; generic programming
;; syntax									basic rules code must follow to be valid statements in a language; simple syntax is a defining Lisp feature
;; semantics								the meaning of a piece of code; the actions the program performs
;; symmetry									imbued in Lisp commands and data structures, giving the language a special elegance
;; recursion								a function that calls itself, a technique strongly encouraged in Lisp
;; namespaces								Lisp has separate namespaces for functions and variables
;; homoiconic								a programming language that uses the same data structures to store data and program code (ex. switching between data mode and code mode in Lisp)
;; generic function							a function that can accept multiple datatypes as parameters and handle them appropriately (ex. substitute-if); can be slower to execute because of the extra checking
;; dynamically typed language				a language such as Lisp whose parameters and variables can hold any type of data
;; garbage collection						feature of a language where variables never have to be "freed" because they are destroyed automatically when they are no longer needed (Lisp was the first language to have tis feature)

;; socket								a mechanism for routing data over a computer network between programs running on different computers on that network
;; socket address						property of a socket, comprised of an IP address and port number
;; IP address							a number that uniquely identifies a computer on a network (typically shown as 4 bytes delimited by periods)
;; port number							a unique number associated with a program on a network
;; TCP packet							a chunk of data containing a message that is sent over a network; labeled with a socket address to indicate its destination
;; socket connection					needed to send a message over a socket between two programs
;; server								the computer with the socket in a listening state
;; client								the program that creates a socket and establishes a connection with the server
;; blocking operation					a command that won't exit until a client has connected
;; Hypertext Transfer Protocol (HTTP)	the Internet protocol used for transferring web pages
;; request header						the first line of an HTTP request; contains the type of request made (ex. GET) and the name of the page requested
;; request body/request content			additional information below the request header
;; response header						information about the document sent in the response body by a server in response to an HTTP request; ex. whether it is in HTML or another format
;; response body						the HTML document sent by the server in response to an HTTP request
;; GET request							a request where the page just needs to be looked at but not modified; however, may contain request parameters that will be seen in the URL of the request
;; POST request							a request that usually carries the expectation that it may alter data on the server; the request parameters are hidden in the body of the request
;; request parameters					the values of the fields sent to the server as part of a POST request
;; HTTP escape codes					enable characters in the values of a request parameter that would not otherwise be available in the HTTP format (ex. foo? -> foo%3F)

;; read-eval-print loop (REPL)			environment where a Lisp expression can be typed in and is immediately evaluated
;; top-level definition					a globally defined variable in Lisp
;; earmuffs								the asterisks ** that surround the name of a global variable; "optional" but should be used as convention
;; list									the basic building block of Lisp code, organized with parentheses; the same thing as a long chain of two-item cons cells
;; cons cell							a small chunk of memory Lisp allocates that can hold two references to the objects being linked with the cons function; aka the structures that hold lists in Lisp together; a chain of cons cells is the same thing as a list
;; consing								using the cons function to link two pieces of data
;; nil									a special symbol used to terminate a list in Lisp
;; empty list							an empty list (); treated as a false value (the only one in Lisp) and can be used interchangeably with nil
;; nested list							a list within a list; under the hood, it's all cons cells; can express hierarchical/tree-like data very naturally
;; dotted list							a list in Lisp that ends in something other than a nil; notated with a dot . indicating the following final item was not nil as expected; an alternate syntax for the cons command, used in data mode; can be used to elegantly represent pairs
;; circular list						a list where the cdr slot of the last cons cell points back to an upstream cons cell rather than to nil; use (setf *print-circle t) before playing with circular lists
;; association list (alist)				a list of key/value pairs; a great way to keep track of any changeable collection of key/value pairs; only efficient with lists under a dozen items
;; symbol								a stand-alone word in Lisp; case-insensitive
;; escaped characters					a special character (such as double quote or backslash) that should be included as part of a string; prefixed with a backlash \
;; code mode							default mode that Lisp assumes code is written in and tries to execute
;; data mode							mode where code is treated as data (a list of items) and Lisp does not try to execute it; indicated with a single quote '
;; quoting								placing a quote in front of lists so that they won't be evaluated (aka put into data mode)
;; quasiquoting							feature of Lisp that allows creation of chunks of data with small pieces of Lisp code embedded in them; use a backquote ` rather than a single quote ' when switching from code to data mode
;; form									a list with a special comman at the beginning (typically the name of a function)
;; shortcut Boolean evaluation			once Lisp determines that an earlier statement in a list of or values is true (or an and value is false), it returns true immediately and doesn't evaluate the remaining statements
;; higher-order functions				functions that take other functions as parameters (ex. mapcar); a distinguishing feature of Lisp
;; #									indicates a Lisp array
;; #'									shorthand for the function operator; required when referring to a function as a value directly to prevent function name conflict
;; #\									creates a Lisp character literal when placed in front of the character; special built-in literals include #\newline, #\tab, and #\space
;; predicates							functions that return either nil or a truth value; a p is appended to the end of the function's name by convention
;; keyword parameter					a special parameter passed in at the end of a function call that can access optional built in features; has two parts: name (a symbole beginning with a colon :), and value
;; keyword symbol						a colon-prepended symbol in Common Lisp; always means itself
;; push/assoc idiom						common Lisp technique used to preserve previous values in a changing alist; old values are suppressed by new values in the alist, since push adds items to the front and assoc only returns the first matching item
;; first-class values					actual values that can be viewed and passed around; in Lisp, functions are first-class values
;; lambda functions						functions created using the lambda macro, not the lambda macro itself
;; nullery functions					small functions that have zero arguments (common in Lisp)
;; thunk (suspension)					a nullery function in Lisp that describes a computation that won't be run until later (for example, print stuff to the console, wrap it in a thunk, redirect the resuls to another location)
;; delayed computation					computations in a program that have a delayed execution (like those inside a thunk)
;; stream								special Common Lisp datatype object used for communicating with an outside source (ex. can be connected to a file to write or read from it)
	;; console stream					stream that communicates with the REPL
	;; file stream						stream that reads and writes to files on the hard drive
	;; socket stream					stream that communicates with other computers on a network
	;; string stream					stream that sends and receives text from a Lisp string
;; output stream						stream that writes data to a resource
;; input stream							stream that reads data from a resource
;; bidriectional stream					stream that can act both as an input stream and an output stream
;; array								similar to a list in Common Lisp, but require only a constant amount of time to access a value at any specific location; indicated with a hash # in front of a list
;; generic setters						feature supported by a language such as Lisp when the code for pulling a value out of a data structure is identical to the code for putting data into that same data structure
;; generalized reference				special sublanguage of Common Lisp used in the first argument in setf
;; hash table							a data structure that stores items using a lookup key and a value like an alist, but allows access to arbitrary elements more quickly; performance benefits are only noticeable when they contain larger amounts of data
;; structure							advanced datatype available in Common Lisp that can be used to represent objects with properties; lends itself to object-oriented programming and encoding objects with multiple properties that must be mutable
;; slots								the properties in a structure
;; mutation								a change to part of a data structure over time; to change the value of a specific property in a structure is also known as mutating the property
;; sequence								a list, array, or string
;; sequence functions					functions that work generically across the three main ways of sequencing objects in Lisp: lists, arrays, and strings
;; type dispatching						having a compiler/interpreter choose among different versions of a function based on argument types
;; string builders						devices used by many programming languages to avoid the performance bottleneck of concatenating very long strings; string streams are the Lisp equivalent
;; signaling a condition				using a Lisp function to notify the Lisp environment that something has gone wrong/a problem has been encountered
;; restart								a piece of code to be called after a problem is encountered in a program once it is safe to proceed
;; ASCII codes							a standard set of numbers that correspond to text characters, shared among many computer systems and applications
;; accumulator							a variable that keeps a running count of how many items in a list have already been encountered
;; precedence							concept where if two definitions of a variable exist in a function (for ex. one as an argument and one locally defined), the version locally defined will be used
;; variable shadowing					hiding one variable with another through precedence
;; reduction function					the function passed as the first argument to reduce
;; orthogonal							property of components of a program where they can be handled independently (such as the way AI game board positions are evaluated vs. how deep to search for the next move)
;; heuristic							a programming technique that is imperfect but allows for obaining good results very quickly